<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>跨域问题和解决方案</title>
      <link href="/post/4a0485cc.html"/>
      <url>/post/4a0485cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="跨域问题及解决方案"><a href="#跨域问题及解决方案" class="headerlink" title="跨域问题及解决方案"></a>跨域问题及解决方案</h1><h2 id="同源策略及跨域问题"><a href="#同源策略及跨域问题" class="headerlink" title="同源策略及跨域问题"></a>同源策略及跨域问题</h2><p><strong>同源策略</strong>是一套浏览器<strong>安全机制</strong>，当一个<strong>源</strong>的文档和脚本，与另一个<strong>源</strong>的资源进行通信时，同源策略就会对这个通信做出不同程度的限制。</p><p>简单来说，同源策略对 <strong>同源资源</strong> <strong>放行</strong>，对 <strong>异源资源</strong> <strong>限制</strong></p><p>因此限制造成的开发问题，称之为<strong>跨域（异源）问题</strong></p><h3 id="同源和异源"><a href="#同源和异源" class="headerlink" title="同源和异源"></a>同源和异源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源(origin) = 协议 + 域名 + 端口</span><br></pre></td></tr></table></figure><p>例如:</p><p><code>https://study.duyiedu.com/api/movie</code>的源为<code>https://study.duyiedu.com</code></p><p><code>http://localhost:7001/index.html</code>的源为<code>http://localhost:7001</code></p><p>两个URL地址的源<strong>完全相同</strong>，则称之为<strong>同源</strong>，否则称之为<strong>异源（跨域）</strong></p><p><img src="http://mdrs.yuanjin.tech/img/202301121634016.png" alt="image-20230112163455982"></p><h3 id="跨域出现的场景"><a href="#跨域出现的场景" class="headerlink" title="跨域出现的场景"></a>跨域出现的场景</h3><p>跨域可能出现在三种场景：</p><ul><li><p><strong>网络通信</strong></p><p>a元素的跳转；加载css、js、图片等；AJAX等等</p></li><li><p>JS API</p><p><code>window.open</code>、<code>window.parent</code>、<code>iframe.contentWindow</code>等等</p></li><li><p>存储</p><p><code>WebStorage</code>、<code>IndexedDB</code>等等</p></li></ul><p>对于不同的跨域场景，以及每个场景中不同的跨域方式，同源策略都有不同的限制。</p><p>本文重点讨论<strong>网络通信</strong>中<code>AJAX</code>的跨域问题</p><h3 id="网络中的跨域"><a href="#网络中的跨域" class="headerlink" title="网络中的跨域"></a>网络中的跨域</h3><p>当浏览器运行页面后，会发出很多的网络请求，例如CSS、JS、图片、AJAX等等</p><p>请求页面的源称之为<strong>页面源</strong>，在该页面中发出的请求称之为<strong>目标源</strong>。</p><p>当页面源和目标源一致时，则为<strong>同源请求</strong>，否则为<strong>异源请求（跨域请求）</strong></p><p><img src="http://mdrs.yuanjin.tech/img/202301121636551.png" alt="image-20230112163616513"></p><h3 id="浏览器如何限制异源请求？"><a href="#浏览器如何限制异源请求？" class="headerlink" title="浏览器如何限制异源请求？"></a>浏览器如何限制异源请求？</h3><p>浏览器出于多方面的考量，制定了非常繁杂的规则来限制各种跨域请求，但总体的原则非常简单：</p><ul><li>对标签发出的跨域请求轻微限制</li><li>对AJAX发出的跨域请求<strong>严厉限制</strong></li></ul><p><img src="http://mdrs.yuanjin.tech/img/202301122010888.png" alt="image-20230112201027855"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（Cross-Origin Resource Sharing）是最正统的跨域解决方案，同时也是浏览器推荐的解决方案。</p><p>CORS是一套规则，用于帮助浏览器判断是否校验通过。</p><p><img src="http://mdrs.yuanjin.tech/img/202301122025029.png" alt="image-20230112202539003"></p><p>CORS的基本理念是：</p><ul><li>只要服务器明确表示<strong>允许</strong>，则校验<strong>通过</strong></li><li>服务器明确拒绝或没有表示，则校验不通过</li></ul><p><strong>所以，使用CORS解决跨域，必须要保证服务器是「自己人」</strong></p><h4 id="请求分类"><a href="#请求分类" class="headerlink" title="请求分类"></a>请求分类</h4><p>CORS将请求分为两类：==简单请求==和==预检请求==。</p><p>对不同种类的请求它的规则有所区别。</p><p>所以要理解CORS，首先要理解它是如何划分请求的。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><blockquote><p>完整判定逻辑：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests</a></p></blockquote><p>简单来说，只要全部满足下列条件，就是简单请求：</p><ul><li><p>请求方法是<code>GET</code>、<code>POST</code>、<code>HEAD</code>之一</p></li><li><p>头部字段满足CORS安全规范，详见 <a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header">W3C</a></p><blockquote><p>浏览器默认自带的头部字段都是满足安全规范的，只要开发者不改动和新增头部，就不会打破此条规则</p></blockquote></li><li><p>如果有<code>Content-Type</code>，必须是下列值中的一个</p><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul></li></ul><h5 id="预检请求-preflight"><a href="#预检请求-preflight" class="headerlink" title="预检请求(preflight)"></a>预检请求(preflight)</h5><p>只要不是简单请求，均为预检请求</p><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的跨域请求哪些是简单请求，哪些是预检请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://douyin.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://douyin.com&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://douyin.com&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://douyin.com&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="对简单请求的验证"><a href="#对简单请求的验证" class="headerlink" title="对简单请求的验证"></a>对简单请求的验证</h4><p><img src="http://mdrs.yuanjin.tech/img/202301122045614.png" alt="image-20230112204546583"></p><h4 id="对预检请求的验证"><a href="#对预检请求的验证" class="headerlink" title="对预检请求的验证"></a>对预检请求的验证</h4><ol><li>发送预检请求</li></ol><p><img src="http://mdrs.yuanjin.tech/img/202301122046532.png" alt="image-20230112204634493"></p><ol start="2"><li>发送真实请求（和简单请求一致）</li></ol><h4 id="细节1-关于cookie"><a href="#细节1-关于cookie" class="headerlink" title="细节1 - 关于cookie"></a>细节1 - 关于cookie</h4><p>默认情况下，ajax的跨域请求并不会附带cookie，这样一来，某些需要权限的操作就无法进行</p><p>不过可以通过简单的配置就可以实现附带cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xhr</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch api</span></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;include&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样一来，该跨域的ajax请求就是一个<em>附带身份凭证的请求</em></p><p>当一个请求需要附带cookie时，无论它是简单请求，还是预检请求，都会在请求头中添加<code>cookie</code>字段</p><p>而服务器响应时，需要明确告知客户端：服务器允许这样的凭据</p><p>告知的方式也非常的简单，只需要在响应头中添加：<code>Access-Control-Allow-Credentials: true</code>即可</p><p>对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。</p><p>另外要特别注意的是：**对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin 的值为*</code>*<em>。这就是为什么不推荐使用</em>的原因</p><h4 id="细节2-关于跨域获取响应头"><a href="#细节2-关于跨域获取响应头" class="headerlink" title="细节2 - 关于跨域获取响应头"></a>细节2 - 关于跨域获取响应头</h4><p>在跨域访问时，JS只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p><p><code>Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: authorization, a, b</span><br></pre></td></tr></table></figure><p>这样JS就能够访问指定的响应头了。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>在很久很久以前…并没有CORS方案</p><p><img src="http://mdrs.yuanjin.tech/img/202301122054396.png" alt="image-20230112205454350"></p><p>在那个年代，古人靠着非凡的智慧来解决这一问题</p><p><img src="http://mdrs.yuanjin.tech/img/202301122056031.png" alt="image-20230112205613983"></p><p>虽然可以解决问题，但JSONP有着明显的缺陷：</p><ul><li><p>仅能使用GET请求</p></li><li><p>容易产生安全隐患</p><blockquote><p>恶意攻击者可能利用<code>callback=恶意函数</code>的方式实现<code>XSS</code>攻击</p></blockquote></li><li><p>容易被非法站点恶意调用</p></li></ul><p><strong>因此，除非是某些特殊的原因，否则永远不应该使用JSONP</strong></p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>CORS和JSONP均要求服务器是「自己人」</p><p>那如果不是呢？</p><img src="http://mdrs.yuanjin.tech/img/202301122105697.png" alt="image-20230112210551647" style="zoom:50%;" /><p>那就找一个中间人（代理）</p><p><img src="http://mdrs.yuanjin.tech/img/202301151333985.png" alt="image-20230115133326930"></p><p>比如，前端小王想要请求获取王者荣耀英雄数据，但直接请求腾讯服务器会造成跨域</p><p><img src="http://mdrs.yuanjin.tech/img/202301151337612.png" alt="image-20230115133732560"></p><p>由于腾讯服务器不是「自己人」，小王决定用代理解决</p><p><img src="http://mdrs.yuanjin.tech/img/202301151338609.png" alt="image-20230115133817554"></p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>最重要的，是要保持<strong>生产环境和开发环境一致</strong></p><p>下面是一张决策图</p><p><img src="http://mdrs.yuanjin.tech/img/202301151453393.png" alt="image-20230115145335319"></p><p>具体的几种场景</p><p><img src="http://mdrs.yuanjin.tech/img/202301151506803.png" alt="image-20230115150610750"></p><p><img src="http://mdrs.yuanjin.tech/img/202301151514837.png" alt="image-20230115151406797"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 同源策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的通信能力</title>
      <link href="/post/7fad1506.html"/>
      <url>/post/7fad1506.html</url>
      
        <content type="html"><![CDATA[<h2 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h2><p>浏览器可以代替用户完成http请求，代替用户解析响应结果，所以我们称之为：</p><p><strong>用户代理 user agent</strong></p><p>在网络层面，对于前端开发者，必须要知道浏览器拥有的两大核心能力：</p><ul><li>自动发出请求的能力</li><li>自动解析响应的能力</li></ul><h3 id="自动发出请求的能力"><a href="#自动发出请求的能力" class="headerlink" title="自动发出请求的能力"></a>自动发出请求的能力</h3><p>当一些事情发生的时候，浏览器会代替用户自动发出http请求，常见的包括：</p><ol><li><p><strong>用户在地址栏输入了一个url地址，并按下了回车</strong></p><p>浏览器会自动解析URL，并发出一个<code>GET</code>请求，同时抛弃当前页面。</p></li><li><p><strong>当用户点击了页面中的a元素</strong></p><p>浏览器会拿到a元素的href地址，并发出一个<code>GET</code>请求，同时抛弃当前页面。</p></li><li><p><strong>当用户点击了提交按钮<code>&lt;button type=&quot;submit&quot;&gt;...&lt;/button&gt;</code></strong></p><p>浏览器会获取按钮所在的<code>&lt;form&gt;</code>元素，拿到它的<code>action</code>属性地址，同时拿到它<code>method</code>属性值，然后把表单中的数据组织到请求体中，发出<code>指定方法</code>的请求，同时抛弃当前页面。</p><blockquote><p>这种方式的提交现在越来越少见了</p></blockquote></li><li><p><strong>当解析HTML时遇到了<code>&lt;link&gt; &lt;img&gt; &lt;script&gt; &lt;video&gt; &lt;audio&gt;</code>等元素</strong></p><p>浏览器会拿到对应的地址，发出<code>GET</code>请求</p></li><li><p><strong>当用户点击了刷新</strong></p><p>浏览器会拿到当前页面的地址，以及当前页面的请求方法，重新发一次请求，同时抛弃当前页面。</p></li></ol><blockquote><p>浏览器在发出请求时，会自动附带一些请求头</p></blockquote><p>==重点来了==</p><p>从古至今，浏览器都有一个约定：</p><p><strong>当发送GET请求时，浏览器不会附带请求体</strong></p><p>这个约定深刻的影响着后续的前后端各种应用，现在，几乎所有人都在潜意识中认同了这一点，无论是前端开发人员还是后端开发人员。</p><p>由于前后端程序的默认行为，逐步造成了GET和POST的各种差异：</p><ol><li><p>浏览器在发送 GET 请求时，不会附带请求体</p></li><li><p>GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。</p></li><li><p>GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制</p></li><li><p>大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中</p></li><li><p>POST 不会被保存到浏览器的历史记录中</p></li><li><p>刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。</p></li></ol><h3 id="自动解析响应的能力"><a href="#自动解析响应的能力" class="headerlink" title="自动解析响应的能力"></a>自动解析响应的能力</h3><p>浏览器不仅能发送请求，还能够针对服务器的各种响应结果做出不同的自动处理</p><p>常见的处理有：</p><ol><li><p><strong>识别响应码</strong></p><p>浏览器能够自动识别响应码，当出现一些特殊的响应码时浏览器会自动完成处理，比如<code>301、302</code></p></li><li><p><strong>根据响应结果做不同的处理</strong></p><p>浏览器能够自动分析响应头中的<code>Content-Type</code>，根据不同的值进行不同处理，比如：</p><ul><li><p><code>text/plain</code>: 普通的纯文本，浏览器通常会将响应体原封不动的显示到页面上</p></li><li><p><code>text/html</code>：html文档，浏览器通常会将响应体作为页面进行渲染</p></li><li><p><code>text/javascript</code>或<code>application/javascript</code>：js代码，浏览器通常会使用JS执行引擎将它解析执行</p></li><li><p><code>text/css</code>：css代码，浏览器会将它视为样式</p></li><li><p><code>image/jpeg</code>：浏览器会将它视为jpg图片</p></li><li><p><code>application/octet-stream</code>：二进制数据，会触发浏览器下载功能</p></li><li><p><code>attachment</code>：附件，会触发下载功能</p><p>该值和其他值不同，应放到<code>Content-Disposition</code>头中。</p></li></ul></li></ol><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><blockquote><p>访问：<a href="https://oss.duyiedu.com/test/index.html">https://oss.duyiedu.com/test/index.html</a></p></blockquote><p><img src="http://mdrs.yuanjin.tech/img/20220428165634.png" alt="image-20220428165629557"></p><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><blockquote><p>浏览器本身就具备网络通信的能力，但在早期，浏览器并没有把这个能力开放给JS。</p><p>最早是微软在IE浏览器中把这一能力向JS开放，让JS可以在代码中实现发送请求，并不会刷新页面，这项技术在2005年被正式命名为AJAX（<strong>A</strong>synchronous <strong>J</strong>avascript <strong>A</strong>nd <strong>X</strong>ML）</p></blockquote><p>AJAX 就是指在web应用程序中异步向服务器发送请求。</p><p>它的实现方式有两种，<code>XMLHttpRequest 简称XHR</code>和<code>Fetch</code></p><p>以下是两者的对比</p><table><thead><tr><th>功能点</th><th>XHR</th><th>Fetch</th></tr></thead><tbody><tr><td>基本的请求能力</td><td>✅</td><td>✅</td></tr><tr><td>基本的获取响应能力</td><td>✅</td><td>✅</td></tr><tr><td>监控请求进度</td><td>✅</td><td>❌</td></tr><tr><td>监控响应进度</td><td>✅</td><td>✅</td></tr><tr><td>Service Worker中是否可用</td><td>❌</td><td>✅</td></tr><tr><td>控制cookie的携带</td><td>❌</td><td>✅</td></tr><tr><td>控制重定向</td><td>❌</td><td>✅</td></tr><tr><td>请求取消</td><td>✅</td><td>✅</td></tr><tr><td>自定义referrer</td><td>❌</td><td>✅</td></tr><tr><td>流</td><td>❌</td><td>✅</td></tr><tr><td>API风格</td><td><code>Event</code></td><td><code>Promise</code></td></tr><tr><td>活跃度</td><td>停止更新</td><td>不断更新</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户代理 </tag>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络分层模型和计算协议</title>
      <link href="/post/b14de456.html"/>
      <url>/post/b14de456.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络分层模型和应用协议"><a href="#网络分层模型和应用协议" class="headerlink" title="网络分层模型和应用协议"></a>网络分层模型和应用协议</h1><h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h2><h3 id="分层的意义"><a href="#分层的意义" class="headerlink" title="分层的意义"></a>分层的意义</h3><p>当遇到一个复杂问题的时候，可以使用分层的思想把问题简单化</p><p>比如，你有半杯82年的可乐，想分享给你的朋友王富贵，但你们已经10年没有联系了。要完成这件事，你可能要考虑：</p><ul><li><p>我用什么装可乐？</p><p>可能的方案：塑料瓶、玻璃瓶、煤气罐</p></li><li><p>怎么保证可乐始终处于低温？</p><p>可能的方案：保温杯、小冰箱、冰盒</p></li><li><p>如何保证可乐不被运输的人偷喝？</p><p>可能的方案：封条、在上面写「毒药」</p></li><li><p>如何获取王富贵的地址？</p><p>可能的方案：报案失踪、联系私人侦探、联系物流公司的朋友</p></li><li><p>如何运输？</p><p>可能的方案：自行车、汽车、火车、高铁、飞机、火箭</p></li></ul><p>这就形成了一个分层结构</p><img src="http://mdrs.yuanjin.tech/img/20210927145456.png" alt="image-20210927145456656" style="zoom:50%;" />  <p>从常理出发，我们可以得出以下结论：</p><ul><li>每层相对独立，只需解决自己的问题</li><li>每层无须考虑上层的交付，仅需把自己的结果交给下层即可</li><li>每层有多种方案可供选择，选择不同的方案不会对上下层造成影响</li><li>每一层会在上一层的基础上增加一些额外信息</li></ul><h3 id="五层网络模型"><a href="#五层网络模型" class="headerlink" title="五层网络模型"></a>五层网络模型</h3><p>网络要解决的问题是：<strong>两个程序之间如何交换数据</strong>。</p><p>这是一个非常复杂的问题，因为两个程序有可能出现在不同的设备上。</p><p>面对复杂的问题，可以使用分层的方式来简化。</p><p>经过不断的演化，网络最终形成了五层模型：</p><p><img src="http://mdrs.yuanjin.tech/img/20211008163417.png" alt="image-20211008163417521"></p><h3 id="数据的传输"><a href="#数据的传输" class="headerlink" title="数据的传输"></a>数据的传输</h3><p><img src="http://mdrs.yuanjin.tech/img/20211008163458.png" alt="image-20211008163458168"></p><h3 id="四层、五层、七层"><a href="#四层、五层、七层" class="headerlink" title="四层、五层、七层"></a>四层、五层、七层</h3><p><img src="http://mdrs.yuanjin.tech/img/20211008164017.png" alt="image-20211008164017299"></p><h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL（uniform resource locator，统一资源定位符）用于定位网络服务</p><p><img src="http://mdrs.yuanjin.tech/img/202301121041726.png" alt="image-20230112104100679"></p><p>URL是一个固定格式的字符串</p><p><img src="http://mdrs.yuanjin.tech/img/202301121029498.png" alt="image-20230112102913056"></p><p>它表达了：</p><p>从网络中==哪台计算机（domain）==中的==哪个程序（port）==寻找==哪个服务（path）==，并注明了获取服务的==具体细节（path）==，以及要用什么样的==协议通信（schema）==</p><p>这里面包含了一些细节：</p><ul><li>当协议是<code>http</code>端口为<code>80</code>时，端口可以省略</li><li>当协议是<code>https</code>端口为<code>443</code>时，端口可以省略</li><li><code>schema</code>、<code>domain</code>、<code>path</code>是必填的，其他的根据具体的要求填写</li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议（Hyper Text Transfer Protocol，<em>HTTP</em>）是一个广泛运用于互联网的应用层协议。</p><p>99%的情况下，前端开发者接触的都是HTTP协议。</p><p>该协议规定了两个方面的内容：</p><ul><li><strong>传递消息的模式</strong></li><li><strong>传递消息的格式</strong></li></ul><h4 id="传递消息的模式"><a href="#传递消息的模式" class="headerlink" title="传递消息的模式"></a>传递消息的模式</h4><p><img src="http://mdrs.yuanjin.tech/img/202301121100790.png" alt="image-20230112110047746"></p><p>HTTP使用了一种极为简单的消息传递模式，「请求-响应」模式</p><p>发起请求的称之为客户端，接收请求并完成响应的称之为服务器。</p><p>「请求-响应」完成后，一次交互结束。</p><h4 id="传递消息的格式"><a href="#传递消息的格式" class="headerlink" title="传递消息的格式"></a>传递消息的格式</h4><p><img src="http://mdrs.yuanjin.tech/img/202301132143345.png" alt="image-20230113214343300"></p><p>HTTP的消息格式是一种纯文本的格式，文本分为三个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求行</span><br><span class="line">请求头</span><br><span class="line"></span><br><span class="line">请求体</span><br></pre></td></tr></table></figure><p><strong>具体每一部分写什么内容，要看具体的服务要求</strong></p><h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>请求行中的第一个单词是请求方法</p><p><strong>在HTTP协议中，请求方法仅有语义的区别</strong>，只是表达了这次请求的「愿望」。</p><blockquote><p>关于请求方法的协议原文见 <a href="https://www.rfc-editor.org/rfc/rfc7231.html">HTTP/1.1规范RFC7231-Chapter4</a></p><p><img src="http://mdrs.yuanjin.tech/img/202301131908971.png" alt="image-20230113190854930"></p></blockquote><p>比如<code>GET</code>表达了客户端想要获取一些东西，<code>POST</code>表达了客户端想要提交一些东西</p><p>常见的请求方法有：</p><ul><li><code>GET</code>：获取</li><li><code>POST</code>：提交</li><li><code>PUT</code>：修改</li><li><code>DELETE</code>：删除</li></ul><p><strong>具体在开发中应该选择什么请求方法，一定是看服务方的要求</strong></p><p>通常情况下：</p><ul><li>获取数据一般使用<code>GET</code></li><li>提交数据一般使用<code>POST</code></li><li>各种静态资源的获取，一般使用<code>GET</code></li></ul><h5 id="请求头-Host"><a href="#请求头-Host" class="headerlink" title="请求头 - Host"></a>请求头 - <code>Host</code></h5><p><code>Host</code>标注了<code>URL</code>地址中的<code>Domain + Port</code></p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: study.duyiedu.com</span><br></pre></td></tr></table></figure><h5 id="请求头-Content-Type"><a href="#请求头-Content-Type" class="headerlink" title="请求头 - Content-Type"></a>请求头 - <code>Content-Type</code></h5><p><code>Content-Type</code>标注了附带的请求体是什么格式</p><p>比如，请求体的数据为<code>loginId:admin, loginPwd:123456</code>，请求体可以用不同的格式发出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">loginId=admin&amp;loginPwd=123123</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123; &quot;loginId&quot;: &quot;admin&quot;, &quot;loginPwd&quot;: &quot;123123&quot; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=aaa</span><br><span class="line"></span><br><span class="line">--aaa</span><br><span class="line">Content-Disposition: form-data; name=&quot;loginId&quot;</span><br><span class="line"></span><br><span class="line">admin</span><br><span class="line">--aaa</span><br><span class="line">Content-Disposition: form-data; name=&quot;loginPwd&quot;</span><br><span class="line"></span><br><span class="line">123456</span><br><span class="line">--aaa</span><br><span class="line">Content-Disposition: form-data; name=&quot;avatar&quot;; filename=&quot;small.jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">文件的二进制</span><br><span class="line">--aaa--</span><br></pre></td></tr></table></figure><h5 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h5><p>响应码（状态码、消息码）是响应行中的一个数字，后面往往跟上一个对应的单词，用于表达服务器对这个响应的整体「态度」</p><p>常见的响应码有：</p><p><img src="http://mdrs.yuanjin.tech/img/202301121310570.png" alt="image-20230112131000507"></p><p>常见的状态码有：</p><ol><li><p>200 OK：一切正常。</p></li><li><p>301 Moved Permanently：资源已被永久重定向。</p><p><code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我已经永远的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了响应头的Location中了</code></p><blockquote><p>试试请求：<a href="http://www.douyutv.com/">www.douyutv.com</a></p></blockquote></li><li><p>302 Found：资源已被临时重定向。</p><p><code>你的请求我收到了，但是呢，你要的东西不在这个地址了，我临时的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了请求头的Location中了</code></p></li><li><p>304 Not Modified：文档内容未被修改。</p><p><code>你的请求我收到了，你要的东西跟之前是一样的，没有任何的变化，所以我就不给你结果了，你自己就用以前的吧。啥？你没有缓存以前的内容，关我啥事</code></p></li><li><p>400 Bad Request：语义有误，当前请求无法被服务器理解。</p><p><code>你给我发的是个啥啊，我听都听不懂</code></p></li><li><p>403 Forbidden：服务器拒绝执行。</p><p><code>你的请求我已收到，但是我就是不给你东西</code></p></li><li><p>404 Not Found：资源不存在。</p><p><code>你的请求我收到了，但我没有你要的东西</code></p></li><li><p>500 Internal Server Error：服务器内部错误。</p><p><code>你的请求我已收到，但这道题我不会，解不出来，先睡了</code></p></li></ol><h5 id="响应头-Content-Type"><a href="#响应头-Content-Type" class="headerlink" title="响应头 - Content-Type"></a>响应头 - <code>Content-Type</code></h5><p><code>Content-Type</code>标注了附带的响应体是什么格式</p><p>常见的值有：</p><ol><li><code>text/plain</code>: 普通的纯文本</li><li><code>text/html</code>：html文档</li><li><code>text/javascript</code> 或 <code>application/javascript</code>：js代码</li><li><code>text/css</code>：css代码</li><li><code>image/jpeg</code>：jpg图片</li><li><code>attachment</code>：附件</li><li>其他<code>MIME</code>类型</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络分层协议 </tag>
            
            <tag> URL </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环详解</title>
      <link href="/post/d775f5bd.html"/>
      <url>/post/d775f5bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><h3 id="何为进程？"><a href="#何为进程？" class="headerlink" title="何为进程？"></a>何为进程？</h3><p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</p><img src="http://mdrs.yuanjin.tech/img/202208092057573.png" alt="image-20220809205743532" style="zoom:50%;" /><p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p><h3 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a>何为线程？</h3><p>线程是系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。</p><p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p><p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p><p><img src="http://mdrs.yuanjin.tech/img/202208092108499.png" alt="image-20220809210859457"></p><p>总结：进程是资源分配的最小单位，线程是程序执行的最小单位。</p><h3 id="浏览器有哪些进程和线程？"><a href="#浏览器有哪些进程和线程？" class="headerlink" title="浏览器有哪些进程和线程？"></a>浏览器有哪些进程和线程？</h3><p><strong>浏览器是一个多进程多线程的应用程序</strong></p><p>浏览器内部工作极其复杂。</p><p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p><p><img src="http://mdrs.yuanjin.tech/img/202208092131410.png" alt="image-20220809213152371"></p><blockquote><p>可以在浏览器的任务管理器中查看当前的所有进程</p></blockquote><p>其中，最主要的进程有：</p><ol><li><p>浏览器进程</p><p>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p></li><li><p>网络进程</p><p>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p></li><li><p><strong>渲染进程</strong></p><p>渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行 HTML、CSS、JS 代码。</p><p>默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p><blockquote><p>将来该默认模式可能会有所改变，可参见<a href="https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability">chrome官方说明文档</a></p></blockquote></li></ol><h2 id="渲染主线程是如何工作的？"><a href="#渲染主线程是如何工作的？" class="headerlink" title="渲染主线程是如何工作的？"></a>渲染主线程是如何工作的？</h2><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画 60 次</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>……</li></ul><blockquote><p>思考：为什么渲染进程不适用多个线程来处理这些事情？</p></blockquote><p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p><p>比如：</p><ul><li>我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？</li><li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？</li><li>浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？</li><li>……</li></ul><p>渲染主线程想出了一个绝妙的主意来处理这个问题：排队</p><p><img src="http://mdrs.yuanjin.tech/img/202208092230847.png" alt="image-20220809223027806"></p><ol><li>在最开始的时候，渲染主线程会进入一个无限循环</li><li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</li><li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li></ol><p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p><p><strong>整个过程，被称之为事件循环（消息循环）</strong></p><h2 id="若干解释"><a href="#若干解释" class="headerlink" title="若干解释"></a>若干解释</h2><h3 id="何为异步？"><a href="#何为异步？" class="headerlink" title="何为异步？"></a>何为异步？</h3><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p><ul><li>计时完成后需要执行的任务 —— <code>setTimeout</code>、<code>setInterval</code></li><li>网络通信完成后需要执行的任务 – <code>XHR</code>、<code>Fetch</code></li><li>用户操作后需要执行的任务 – <code>addEventListener</code></li></ul><p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p><p><img src="http://mdrs.yuanjin.tech/img/202208101043348.png" alt="image-20220810104344296"></p><p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong></p><p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p><p><img src="http://mdrs.yuanjin.tech/img/202208101048899.png" alt="image-20220810104858857"></p><p>使用异步的方式，<strong>渲染主线程永不阻塞</strong></p><blockquote><p><strong>面试题：如何理解 JS 的异步？</strong></p><p>参考答案：</p><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p><p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p></blockquote><h3 id="JS为何会阻碍渲染？"><a href="#JS为何会阻碍渲染？" class="headerlink" title="JS为何会阻碍渲染？"></a>JS为何会阻碍渲染？</h3><p>先看代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>点击按钮，猜猜会发生什么<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> h1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 死循环指定的时间</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">duration</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - start &lt; duration) &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    h1.<span class="property">textContent</span> = <span class="string">&#x27;我出土啦&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">delay</span>(<span class="number">3000</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击按钮后，3秒后文字内容才被替换！</p><h3 id="任务有优先级吗？"><a href="#任务有优先级吗？" class="headerlink" title="任务有优先级吗？"></a>任务有优先级吗？</h3><p>任务没有优先级，在消息队列中先进先出</p><p>但<strong>消息队列是有优先级的</strong></p><p>根据 W3C 的最新解释:</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></li></ul><blockquote><p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p></blockquote><p>在目前 chrome 的实现中，至少包含了下面的队列：</p><ul><li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li><li>微队列：用户存放需要最快执行的任务，优先级「最高」</li></ul><blockquote><p>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即把一个函数添加到微队列</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(函数)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>输出结果：5 1 2 3</p><blockquote><p><strong>面试题：阐述一下 JS 的事件循环</strong></p><p>参考答案：</p><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式，是异步的实现方式。</p><p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p><p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p></blockquote><blockquote><p><strong>面试题：JS 中的计时器能做到精确计时吗？为什么？</strong></p><p>参考答案：</p><p>不行，因为：</p><ol><li>计算机硬件没有原子钟，无法做到精确计时</li><li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li><li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程和线程 </tag>
            
            <tag> 异步 </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染原理</title>
      <link href="/post/a074b2a4.html"/>
      <url>/post/a074b2a4.html</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><img src='https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230305183214.png' title='渲染时间点' width='70%'><blockquote><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p></blockquote><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230307173912.png" title='渲染流水线' width='70%'/><h3 id="解析-HTML"><a href="#解析-HTML" class="headerlink" title="解析 HTML"></a>解析 HTML</h3><p>浏览器解析HTML，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308171916.png" width='70%'/><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><table><thead><tr><th align="center"><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308172132.png" width='99%'/></th><th align="center"><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308172256.png" width='99%'/></th></tr></thead><tbody><tr><td align="center">CSS不会阻塞HTML解析</td><td align="center">JS会阻塞HTML解析</td></tr></tbody></table><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308174847.png" width='70%'/><h3 id="布局，得到布局树"><a href="#布局，得到布局树" class="headerlink" title="布局，得到布局树"></a>布局，得到布局树</h3><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><table><thead><tr><th><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308202955.png"/></th><th><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308203029.png"/></th><th><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308203103.png"/></th></tr></thead></table><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308204243.png" width="70%"/><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308204907.png" width="70%"/><h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308204808.png" width="70%"/><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308205023.png" width='70%'/><h3 id="画"><a href="#画" class="headerlink" title="画"></a>画</h3><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308205832.png" width="70%"/><h3 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h3><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/20230308210718.png" width="70%"/><h2 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h2><h3 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h3><p>reflow （重排、回流）的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h3 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h3><p>repaint（重绘） 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h3 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h3><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Javascript（二）面向对象、事件循环机制</title>
      <link href="/post/69128ee3.html"/>
      <url>/post/69128ee3.html</url>
      
        <content type="html"><![CDATA[<h2 id="3-面向对象高级"><a href="#3-面向对象高级" class="headerlink" title="3. 面向对象高级"></a>3. 面向对象高级</h2><h3 id="3-1-对象创建模式"><a href="#3-1-对象创建模式" class="headerlink" title="3.1 对象创建模式"></a>3.1 对象创建模式</h3><p>new运算符</p><p>当函数用new运算符调用，会被当做构造函数调用；new会有如下操作：</p><ol><li>创建一个普通的空对象{}</li><li>让这个空对象的__proto__指向构造函数的prototype</li><li>将this指向新创建的这个对象</li><li>如果构造函数返回值是非原始值，这个值将作为新对象的值返回；如果没返回值或返回值是原始值，新对象将作为返回值。(正常情况下，不会写返回值)</li><li>Object构造函数方式：先创建Object空对象，再动态添加属性/方法 适用于：起始不确定对象内部数据 缺点：语句多 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p =<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">p.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">p.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br><span class="line">p.<span class="property">setAge</span> = <span class="keyword">function</span>(<span class="params">age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>对象字面量形式：使用{}创建对象，同时指定属性/方法 适用于：起始确定对象内部数据 缺点：创建多个相似对象，代码重复 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">setName</span>:<span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">setAge</span>:<span class="keyword">function</span>(<span class="params">age</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>工厂模式：定义一个工厂函数，内部以字面量形式创建对象，并返回这个对象。 工厂函数：返回一个对象的函数 适用场景：需要创建多个Object对象 缺点：对象没有具体类型，都是Object <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">creatPerson</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>:name,</span><br><span class="line">        <span class="attr">age</span>:age,</span><br><span class="line">        <span class="attr">setName</span>:<span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">setAge</span>:<span class="keyword">function</span>(<span class="params">age</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">creatPerson</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">creatPerson</span>(<span class="string">&quot;Bob&quot;</span>,<span class="number">15</span>);</span><br></pre></td></tr></table></figure></li><li>自定义构造函数：定义一个构造函数，通过new创建对象 适用于：需要创建多个类型确定的对象 缺点：每个对象都有相同的数据, 浪费内存（下例中的setName和setAge重复放入p1 p2） <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setAge</span> = <span class="keyword">function</span>(<span class="params">age</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name,money</span>)&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Danny&quot;</span>,<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//由此，我们就区分了Person与Student两种不同类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 <span class="keyword">instanceof</span> <span class="title class_">Student</span>);</span><br></pre></td></tr></table></figure></li><li>构造函数+原型：自定义构造函数, 属性在函数中初始化, 方法添加到原型上 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setAge</span> = <span class="keyword">function</span>(<span class="params">age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-继承模式"><a href="#3-2-继承模式" class="headerlink" title="3.2 继承模式"></a>3.2 继承模式</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name,age</span>)&#123;     <span class="comment">//this指向Father实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">money</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name,age,score</span>)&#123;   <span class="comment">//this指向Son实例</span></span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name,age);  <span class="comment">//改变this指向，使其指向Son实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使子构造函数原型对象指向Father实例对象</span></span><br><span class="line"><span class="comment">//由于Father实例对象__proto__了Father原型对象,Son实例也可以访问到Father原型对象中的方法</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="comment">//目前Son.prototype.constructor返回结果为Father,将其修正</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span>;</span><br><span class="line"><span class="comment">//为子构造函数添加新方法</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">exam</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&quot;liu&quot;</span>,<span class="number">18</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/image_4.png"></p><h3 id="3-3-面向对象的特点"><a href="#3-3-面向对象的特点" class="headerlink" title="3.3 面向对象的特点"></a>3.3 面向对象的特点</h3><ul><li>封装：对象是存储不同属性的容器，并且负责数据的安全  如何确保数据安全：<ol><li>私有化属性，在属性名前加#，私有属性只能在对象内部访问；</li><li>提供setter和getter方法，暴露属性。灵活控制读写权限，同时还可以进行数据验证。</li></ol>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    #name</span><br><span class="line">    #age</span><br><span class="line">    #gender</span><br><span class="line">    <span class="title function_">construstor</span>(<span class="params">name,age,gender</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.#name = name</span><br><span class="line">        <span class="variable language_">this</span>.#age = age</span><br><span class="line">        <span class="variable language_">this</span>.#gender = gender</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">name</span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.#name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">name</span>()&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.#name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>继承：extends关键字 super引用父类的属性、方法</li><li>多态：JS并不会检查参数的类型，意味着任何类型的参数都可以传入</li></ul><h2 id="4-线程机制与事件机制"><a href="#4-线程机制与事件机制" class="headerlink" title="4. 线程机制与事件机制"></a>4. 线程机制与事件机制</h2><h3 id="4-1-进程与线程"><a href="#4-1-进程与线程" class="headerlink" title="4.1 进程与线程"></a>4.1 进程与线程</h3><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p><strong>总结：</strong></p><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p><p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位</p><h3 id="4-2-JS执行队列"><a href="#4-2-JS执行队列" class="headerlink" title="4.2 JS执行队列"></a>4.2 JS执行队列</h3><p>HTML5提出了web worker标准，允许JS脚本创建多个线程。于是，JS出现了同步和异步。</p><p>JS的异步是通过回调函数实现的。常见的异步任务：</p><p>普通事件，如click、resize等</p><p>加载资源，如load、error等</p><p>定时器，如setInterval、setTimeout等</p><p>同步任务在主线程执行栈中，异步任务在任务队列中。</p><p>执行机制：</p><ol><li>先执行执行栈中的同步任务</li><li>遇到异步任务，将异步任务提交给对应的异步线程处理</li><li>当事件发生，将其推入任务队列</li><li>执行栈中的任务执行完毕，在按次序读取任务队列中中的异步任务，被读取的异步任务进入执行栈，开始执行</li><li>重复step4</li></ol><p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/image_5.png"></p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件循环 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Javascript（一）内存、原型、闭包</title>
      <link href="/post/1070ef03.html"/>
      <url>/post/1070ef03.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据、变量和内存"><a href="#1-数据、变量和内存" class="headerlink" title="1. 数据、变量和内存"></a>1. 数据、变量和内存</h2><h3 id="1-1-数据类型判断"><a href="#1-1-数据类型判断" class="headerlink" title="1.1 数据类型判断"></a>1.1 数据类型判断</h3><ol><li>typeof:<ul><li>可以区别: 数值, 字符串, 布尔值, undefined, function，symbol</li><li>不能区别: null与对象, 数组与一般对象</li><li>返回的是数据类型的字符串表达形式</li></ul> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a = = = <span class="string">&#x27;number&#x27;</span>);<span class="comment">//注意引号</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a) <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure></li><li>instanceof<ul><li>专门用来判断对象数据的类型: Object, Array与Function</li></ul> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = &#123;</span><br><span class="line">    <span class="attr">b2</span>: [<span class="number">2</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="variable language_">console</span>.<span class="property">log</span>],</span><br><span class="line">    <span class="attr">b3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b3()&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>, <span class="keyword">typeof</span> b1); <span class="comment">// true &#x27;object&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1.<span class="property">b2</span> <span class="keyword">instanceof</span> <span class="title class_">Array</span>, <span class="keyword">typeof</span> b1.<span class="property">b2</span>); <span class="comment">// true &#x27;object&#x27;  //typeof不能区分数组与一般对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b1.<span class="property">b3</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>, <span class="keyword">typeof</span> b1.<span class="property">b3</span>); <span class="comment">// true &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure></li><li>===<ul><li>可以判断: undefined和null</li></ul> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a===<span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-1-1常见问题"><a href="#1-1-1常见问题" class="headerlink" title="1.1.1常见问题"></a>1.1.1常见问题</h3><ol><li>undefined与null的区别 undefined：声明，未赋值 null：声明，赋值为null。用于：①初始赋值，表明Object类型；②结束时，断开堆内存链接，被垃圾回收。</li><li>严格区分变量类型与数据类型<br>变量类型：<br>基本类型：保存数据<br>引用类型：保存地址值</li></ol><p>数据类型：</p><p>基本类型</p><p>对象类型</p><h3 id="1-2数据、变量和内存"><a href="#1-2数据、变量和内存" class="headerlink" title="1.2数据、变量和内存"></a>1.2数据、变量和内存</h3><ol><li>var a = xxx；a内存中保存的到底是什么？ ①xxx是基本数据，保存的就是这个数据 ②xxx是对象，保存的是地址值 ③xxx是变量，依变量类型而定</li><li>关于引用变量的赋值问题 ①多个引用变量指向一个对象 ，一个变量的赋值发生变化，其他也随之变化 ②两个引用变量指向一个对象，修改一个变量指向另一个对象，另一变量依然指向前一个对象 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj = &#123;<span class="attr">age</span>:<span class="number">15</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span>);</span><br><span class="line"><span class="comment">//输出结果：18</span></span><br><span class="line"><span class="comment">//解析：传参的过程其实是赋值的过程。将a的地址值赋给obj，obj = &#123;age:15&#125;改变了obj的地址，并未改变a,故a.age仍为18</span></span><br><span class="line"></span><br><span class="line">a = &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">age</span> = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span>);</span><br><span class="line"><span class="comment">//输出结果：15</span></span><br><span class="line"><span class="comment">//解析：obj.age = 15改变了堆内存中age的值，a也随之改变</span></span><br></pre></td></tr></table></figure></li><li>JS如何管理内存？<br>内存生命周期：<br>分配内存空间，得到它的使用权；<br>存储数据，可以反复操作；<br>释放内存</li></ol><p>释放内存：</p><p>为执行函数分配的栈内存: 函数执行完自动释放</p><p>存储对象的堆内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存</p><ol><li>浅拷贝与深拷贝 浅拷贝只拷贝一层，深层次的对象只拷贝引用（地址值）；<br> <img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/image.png"><br> 深拷贝每一级别的数据都会拷贝<br> <img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/image_1.png"></li></ol><h2 id="2-函数高级"><a href="#2-函数高级" class="headerlink" title="2. 函数高级"></a>2. 函数高级</h2><h3 id="2-1对象"><a href="#2-1对象" class="headerlink" title="2.1对象"></a>2.1对象</h3><ol><li>对象是多个数据的集合体(封装体)，用于保存多个数据的容器，便于对多个数据进行统一管理。</li><li>对象的组成 属性：由属性名和属性值组成，属性名都是字符串类型, 属性值是任意类型 方法：是特别的属性（属性值是函数）</li><li>访问对象 .属性名 有时不能用 [‘属性名’]</li><li>只能用[‘属性名’]的情况 ①属性名包含非法字符 ②属性名不确定</li></ol><h3 id="2-2-函数"><a href="#2-2-函数" class="headerlink" title="2.2 函数"></a>2.2 函数</h3><ol><li>函数定义 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表达式，声明提前</span></span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>函数的调用 ①test(); ②obj.test(); ③new Test()； ④test.call(obj); test.apply(obj); 让test临时成为obj的方法，从而改变this的指向</li><li>立即执行函数（IIFE） 作用：隐藏实现 ；不会污染命名空间；用于编码JS模块</li></ol><h3 id="2-3-this"><a href="#2-3-this" class="headerlink" title="2.3 this"></a>2.3 this</h3><p>任何函数本质上都是通过某个对象调用的，如未指定，这个对象默认是window</p><p>所有函数内部都有一个变量this，this指向调用函数的对象</p><p>确定this的指向：</p><ul><li>test(): window</li><li>p.test(): p</li><li>new test(): 新创建的对象</li><li>p.call(obj，…): obj</li></ul><h3 id="2-4-原型prototype"><a href="#2-4-原型prototype" class="headerlink" title="2.4 原型prototype"></a>2.4 原型prototype</h3><h3 id="2-4-1原型与原型对象"><a href="#2-4-1原型与原型对象" class="headerlink" title="2.4.1原型与原型对象"></a>2.4.1原型与原型对象</h3><p>每个函数都有一个prototype属性，他指向一个object对象（原型对象）。</p><p>原型对象中有一个属性constructor，它指向函数本身。由此函数与原型对象构成了双向引用的关系。</p><p>我们可以通过Fun.prototype.test = xxx;来为构造函数的实例添加属性或方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出Date的原型对象：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">//结果如下：</span></span><br></pre></td></tr></table></figure><p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/image_2.png"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过.prototype.constructor获取当前函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Date</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-显式原型与隐式原型"><a href="#2-4-2-显式原型与隐式原型" class="headerlink" title="2.4.2 显式原型与隐式原型"></a>2.4.2 显式原型与隐式原型</h3><p>每个函数Function都有一个prototype，即显式原型；</p><p>每个实例对象都有一个_ <em>proto</em> _，可称为隐式原型；</p><p>他们保存一样的地址值，共同指向原型对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;   <span class="comment">// 自动添加内部语句: this.prototype = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="title class_">Fn</span>();  <span class="comment">// 自动添加内部语句: this.__proto__ = Fn.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>===fn.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型添加方法</span></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test()&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过实例调用原型的方法</span></span><br><span class="line">fn.<span class="title function_">test</span>()</span><br></pre></td></tr></table></figure><h3 id="2-4-3-原型链"><a href="#2-4-3-原型链" class="headerlink" title="2.4.3 原型链"></a>2.4.3 原型链</h3><p><img src="https://xinyuan-1316698451.cos.ap-beijing.myqcloud.com/image_3.png"></p><p>访问一个对象的属性时，</p><ul><li>先在自身属性中查找，找到返回</li><li>如果没有, 再沿着__proto__这条链向上查找, 找到返回</li><li>如果最终没找到, 返回undefined</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 函数的显示原型指向的对象默认是空Object实例对象(但Object不满足)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. 所有函数都是Function的实例(包含Function)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">__proto__</span>===<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3. Object的原型对象是原型链尽头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>设置对象的属性值时，不会查找原型链，如果当前对象没有此属性，则为其添加此属性并设置其值。</p><p>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">fn2.<span class="property">a</span> = <span class="string">&quot;yyy&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn1);<span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn2);<span class="comment">//&#123;a:&quot;yyy&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn1.a = &quot;</span>+fn1.<span class="property">a</span>);<span class="comment">//fn1.a = xxx</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn2.a = &quot;</span>+fn2.<span class="property">a</span>);<span class="comment">//fn2.a = yyy</span></span><br></pre></td></tr></table></figure><h3 id="2-4-4-探索instanceof"><a href="#2-4-4-探索instanceof" class="headerlink" title="2.4.4 探索instanceof"></a>2.4.4 探索instanceof</h3><p>a instanceof B</p><p>如果B的原型对象在a的隐式原型链上，则返回true</p><h3 id="2-5-执行上下文与执行上下文栈"><a href="#2-5-执行上下文与执行上下文栈" class="headerlink" title="2.5 执行上下文与执行上下文栈"></a>2.5 执行上下文与执行上下文栈</h3><p><a href="https://www.wolai.com/25yaZQyY5eZ9KeiaJ48GS4#cqJCq9pPoRH6MWW5CyqSki">声明提前</a></p><p>全局执行上下文：</p><ol><li>在执行全局代码前，将window确定为全局执行上下文</li><li>var定义的全局变量添加到window，值为undefined</li><li>function声明的函数，添加到window的方法</li><li>为this赋值——window</li><li>执行全局代码</li></ol><p>注：先变量提升，再函数提升</p><p>函数执行上下文：</p><ol><li>在调用函数、执行函数之前，创建函数执行上下文对象（虚拟的对象，存在于栈中）</li><li>对局部数据进行预处理： 形参赋值为实参，添加到执行上下文的属性 argument（实参列表）添加到执行上下文的属性 var定义的局部变量添加为执行上下文的属性，值为undefined function声明的函数，添加到执行上下文的方法 为this赋值——谁调用的函数，谁就是this</li><li>开始执行函数代码</li></ol><h3 id="2-6-作用域与作用域链"><a href="#2-6-作用域与作用域链" class="headerlink" title="2.6 作用域与作用域链"></a>2.6 作用域与作用域链</h3><p>作用域与执行上下文的区别与联系</p><ol><li>区别1<ul><li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时</li><li>全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建；函数执行上下文是在调用函数时, 函数体代码执行之前创建</li></ul></li><li>区别2<ul><li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化</li><li>执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放</li></ul></li><li>联系<ul><li>执行上下文(对象)是从属于所在的作用域</li><li>全局上下文环境==&gt;全局作用域</li><li>函数上下文环境==&gt;对应的函数使用域</li></ul></li></ol><p>练习：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">show</span>(fn);  <span class="comment">//10  注意作用域与执行上下文的区别，两个函数作用域是互相独立的，因此输出全局变量</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()   <span class="comment">//输出fn本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">fn2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(fn2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn2</span>()   <span class="comment">//报错。这种写法相当于obj.fn2 = function()&#123;&#125;;需要用this.fn2获取到fn2</span></span><br></pre></td></tr></table></figure><h3 id="2-7-闭包"><a href="#2-7-闭包" class="headerlink" title="2.7 闭包"></a>2.7 闭包</h3><h3 id="2-7-1闭包简介"><a href="#2-7-1闭包简介" class="headerlink" title="2.7.1闭包简介"></a>2.7.1闭包简介</h3><p>高阶函数：参数是函数或返回值是函数</p><ol><li>闭包的产生 当子函数引用了父函数的变量（变量也可以是函数），就产生了闭包。 另：一个作用域有权访问另一个函数的局部变量，这个作用域就称为闭包。</li><li>常见的闭包： ①将函数作为返回值返回 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2 <span class="comment">//也可以写成：returnfunction fn2() &#123; a++; console.log(a); &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn1</span>()</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 4</span></span><br></pre></td></tr></table></figure> ②将函数作为实参传递给另一个函数调用 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showDelay</span>(<span class="params">msg,time</span>)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(msg)</span><br><span class="line">  &#125;,time)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showDelay</span>(<span class="string">&quot;lizhenduo&quot;</span>,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure></li><li>闭包的作用 延长局部变量生命周期：函数内部变量在函数执行完后，仍然在内存中； 让函数外部可以操作到函数内部数据</li><li>闭包的生命周期 子函数定义执行完产生，成为垃圾对象后死亡</li></ol><h3 id="2-7-2-闭包应用：自定义JS模块"><a href="#2-7-2-闭包应用：自定义JS模块" class="headerlink" title="2.7.2 闭包应用：自定义JS模块"></a>2.7.2 闭包应用：自定义JS模块</h3><p>编写js文件，将所有数据和功能封装在一个函数内部（私有的），只向外暴露一个包含n个方法的对象，以供模块的使用者实现对应功能。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//私有数据</span></span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">&#x27;My atguigu&#x27;</span></span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;doSomething() &#x27;</span>+msg.<span class="title function_">toUpperCase</span>())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doOtherthing</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;doOtherthing() &#x27;</span>+msg.<span class="title function_">toLowerCase</span>())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">myModule2</span> = &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doOtherthing</span>: doOtherthing</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="2-7-3内存溢出与泄露"><a href="#2-7-3内存溢出与泄露" class="headerlink" title="2.7.3内存溢出与泄露"></a>2.7.3内存溢出与泄露</h3><p>函数执行完之后，函数内的局部变量没有释放，仍然占用内存，容易造成内存泄露。</p><p>解决办法：能不用闭包就不用；及时释放</p><p>内存溢出：</p><p>一种程序运行时出现的错误。当程序运行需要的内存超过了剩余内存时，就抛出内存溢出的错误。</p><p>内存泄漏：</p><p>占用的内存未及时释放，内存泄漏积累多了就会导致内存溢出。</p><p>常见的内存泄漏：①意外的全局变量；②没有及时清理计时器或回调函数；③闭包</p><h3 id="2-7-4-练习"><a href="#2-7-4-练习" class="headerlink" title="2.7.4 练习"></a>2.7.4 练习</h3><p>见课件</p><h3 id="2-8-递归"><a href="#2-8-递归" class="headerlink" title="2.8 递归"></a>2.8 递归</h3><p>如果一个函数在内部可以调用其本身，就称为递归。为防止内存溢出，必须设置终止条件（return）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打印六句话&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num === <span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="title function_">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用递归求阶乘</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num*<span class="title function_">f</span>(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS属性计算过程</title>
      <link href="/post/711dcc9f.html"/>
      <url>/post/711dcc9f.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>你是否了解 CSS 的属性计算过程呢？</p><p>有的同学可能会讲，CSS属性我倒是知道，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color</span> : red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 CSS 代码中，p 是元素选择器，color 就是其中的一个 CSS 属性。</p><p>但是要说 CSS 属性的计算过程，还真的不是很清楚。</p><p>没关系，通过此篇文章，能够让你彻底明白什么是 CSS 属性的计算流程。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png"  style="zoom:50%;" /><p>首先，不知道你有没有考虑过这样的一个问题，假设在 HTML 中有这么一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个h1标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码也非常简单，就是在 body 中有一个 h1 标题而已，该 h1 标题呈现出来的外观是如下：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060724.png"  style="zoom:50%;" /><p>目前我们没有设置该 h1 的任何样式，但是却能看到该 h1 有一定的默认样式，例如有默认的字体大小、默认的颜色。</p><p>那么问题来了，我们这个 h1 元素上面除了有默认字体大小、默认颜色等属性以外，究竟还有哪些属性呢？</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-014216.png"  style="zoom:30%;" /><p>答案是<strong>该元素上面会有 CSS 所有的属性。</strong>你可以打开浏览器的开发者面板，选择【元素】，切换到【计算样式】，之后勾选【全部显示】，此时你就能看到在此 h1 上面所有 CSS 属性对应的值。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-061516.png"></p><p>换句话说，<strong>我们所书写的任何一个 HTML 元素，实际上都有完整的一整套 CSS 样式</strong>。这一点往往是让初学者比较意外的，因为我们平时在书写 CSS 样式时，往往只会书写必要的部分，例如前面的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color</span> : red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这往往会给我们造成一种错觉，认为该 p 元素上面就只有 color 属性。而真实的情况确是，任何一个 HTML 元素，都有一套完整的 CSS 样式，只不过你没有书写的样式，<strong>大概率可能</strong>会使用其默认值。例如上图中 h1 一个样式都没有设置，全部都用的默认值。</p><p>但是注意，我这里强调的是“大概率可能”，难道还有我们“没有设置值，但是不使用默认值”的情况么？</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-014459.png" style="zoom:25%;" /><p>嗯，确实有的，所以我才强调你要了解“CSS 属性的计算过程”。</p><p>总的来讲，属性值的计算过程，分为如下这么 <em>4</em> 个步骤：</p><ul><li>确定声明值</li><li>层叠冲突</li><li>使用继承</li><li>使用默认值</li></ul><h2 id="确定声明值"><a href="#确定声明值" class="headerlink" title="确定声明值"></a>确定声明值</h2><p>首先第一步，是确定声明值。所谓声明值就是作者自己所书写的 CSS 样式，例如前面的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color</span> : red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们声明了 p 元素为红色，那么就会应用此属性设置。</p><p>当然，除了作者样式表，一般浏览器还会存在“用户代理样式表”，简单来讲就是浏览器内置了一套样式表。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-063500.png"></p><p>在上面的示例中，作者样式表中设置了 color 属性，而用户代理样式表（浏览器提供的样式表）中设置了诸如 display、margin-block-start、margin-block-end、margin-inline-start、margin-inline-end 等属性对应的值。</p><p>这些值目前来讲也没有什么冲突，因此最终就会应用这些属性值。</p><h2 id="层叠冲突"><a href="#层叠冲突" class="headerlink" title="层叠冲突"></a>层叠冲突</h2><p>在确定声明值时，可能出现一种情况，那就是声明的样式规则发生了冲突。</p><p>此时会进入解决层叠冲突的流程。而这一步又可以细分为下面这三个步骤：</p><ul><li>比较源的重要性</li><li>比较优先级</li><li>比较次序</li></ul><p>来来来，我们一步一步来看。</p><h3 id="比较源的重要性"><a href="#比较源的重要性" class="headerlink" title="比较源的重要性"></a>比较源的重要性</h3><p>当不同的 CSS 样式来源拥有相同的声明时，此时就会根据样式表来源的重要性来确定应用哪一条样式规则。</p><p>那么问题来了，咱们的样式表的源究竟有几种呢？</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-100047.png"  style="zoom:40%;" /><p>整体来讲有三种来源：</p><ul><li>浏览器会有一个基本的样式表来给任何网页设置默认样式。这些样式统称<strong>用户代理样式</strong>。</li><li>网页的作者可以定义文档的样式，这是最常见的样式表，称之为<strong>页面作者样式</strong>。</li><li>浏览器的用户，可以使用自定义样式表定制使用体验，称之为<strong>用户样式</strong>。</li></ul><p>对应的重要性顺序依次为：页面作者样式 &gt; 用户样式 &gt; 用户代理样式</p><p>更详细的来源重要性比较，可以参阅 <em>MDN</em>：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade</a></em></p><p>我们来看一个示例。</p><p>例如现在有<strong>页面作者样式表</strong>和<strong>用户代理样式表</strong>中存在属性的冲突，那么会以作者样式表优先。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color</span> : red;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-064222.png"></p><p>可以明显的看到，作者样式表和用户代理样式表中同时存在的 display 属性的设置，最终作者样式表干掉了用户代理样式表中冲突的属性。这就是第一步，根据不同源的重要性来决定应用哪一个源的样式。</p><h3 id="比较优先级"><a href="#比较优先级" class="headerlink" title="比较优先级"></a>比较优先级</h3><p>那么接下来，如果是在在同一个源中有样式声明冲突怎么办呢？此时就会进行样式声明的优先级比较。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span> <span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，同属于<strong>页面作者样式</strong>，源的重要性是相同的，此时会以选择器的权重来比较重要性。</p><p>很明显，上面的选择器的权重要大于下面的选择器，因此最终标题呈现为 <em>50px</em>。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-071546.png"  style="zoom: 40%;" /><p>可以看到，落败的作者样式在 <em>Elements&gt;Styles</em> 中会被划掉。</p><p>有关选择器权重的计算方式，不清楚的同学，可以进入此传送门：<em><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity">https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity</a></em></p><h3 id="比较次序"><a href="#比较次序" class="headerlink" title="比较次序"></a>比较次序</h3><p>经历了上面两个步骤，大多数的样式声明能够被确定下来。但是还剩下最后一种情况，那就是样式声明既是同源，权重也相同。</p><p>此时就会进入第三个步骤，比较样式声明的次序。</p><p>举个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，同样都是<strong>页面作者样式</strong>，<strong>选择器的权重也相同</strong>，此时位于下面的样式声明会层叠掉上面的那一条样式声明，最终会应用 <em>20px</em> 这一条属性值。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-23-103928.png"></p><p>至此，样式声明中存在冲突的所有情况，就全部被解决了。</p><h2 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h2><p>层叠冲突这一步完成后，解决了相同元素被声明了多条样式规则究竟应用哪一条样式规则的问题。</p><p>那么如果没有声明的属性呢？此时就使用默认值么？</p><p><em>No、No、No</em>，别急，此时还有第三个步骤，那就是使用继承而来的值。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们针对 div 设置了 color 属性值为红色，而针对 p 元素我们没有声明任何的属性，但是由于 color 是可以继承的，因此 p 元素从最近的 div 身上继承到了 color 属性的值。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065102.png"></p><p>这里有两个点需要同学们注意一下。</p><p>首先第一个是我强调了是<strong>最近的</strong> div 元素，看下面的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-065653.png"></p><p>因为这里并不涉及到选中 p 元素声明 color 值，而是从父元素上面继承到 color 对应的值，因此这里是<strong>谁近就听谁</strong>的，初学者往往会产生混淆，又去比较权重，但是这里根本不会涉及到权重比较，因为压根儿就没有选中到 p 元素。</p><p>第二个就是哪些属性能够继承？</p><p>关于这一点的话，大家可以在 MDN 上面很轻松的查阅到。例如我们以 text-align 为例，如下图所示：</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070148.png"></p><h2 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h2><p>好了，目前走到这一步，如果属性值都还不能确定下来，那么就只能是使用默认值了。</p><p>如下图所示：</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-070825.png"></p><p>前面我们也说过，一个 HTML 元素要在浏览器中渲染出来，必须具备所有的 CSS 属性值，但是绝大部分我们是不会去设置的，用户代理样式表里面也不会去设置，也无法从继承拿到，因此最终都是用默认值。</p><p>好了，这就是关于 CSS 属性计算过程的所有知识了。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png"  style="zoom:33%;" /><h2 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h2><p>好了，学习了今天的内容，让我来用一道面试题测试测试大家的理解程度。</p><p>下面的代码，最终渲染出来的效果，a 元素是什么颜色？p 元素又是什么颜色？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家能说出为什么会呈现这样的结果么？</p><p>解答如下：</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-071941.png"></p><p>实际上原因很简单，因为 a 元素在用户代理样式表中已经设置了 color 属性对应的值，因此会应用此声明值。而在 p 元素中无论是作者样式表还是用户代理样式表，都没有对此属性进行声明，然而由于 color 属性是可以继承的，因此最终 p 元素的 color 属性值通过继承来自于父元素。</p><p>你答对了么？-）</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 属性计算过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的CSS之包含块</title>
      <link href="/post/298957a4.html"/>
      <url>/post/298957a4.html</url>
      
        <content type="html"><![CDATA[<p>一说到 CSS 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。</p><p>但是一说到 CSS 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142005.png"  style="zoom: 20%;" /><p>好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-13-060434.png"  style="zoom:50%;" /><p>包含块英语全称为<strong>containing block</strong>，实际上平时你在书写 CSS 时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的：</p><p><em><a href="https://drafts.csswg.org/css2/#containing-block-details">https://drafts.csswg.org/css2/#containing-block-details</a></em></p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-142459.png"  style="zoom:50%;" /><p>并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。</p><p>那么，这个包含块究竟说了什么内容呢？</p><p>说起来也简单，<strong>就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。</strong></p><p>来吧，少年，让我们从最简单的 case 开始看。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143153.png"  style="zoom: 50%;" /><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-143451.png"  style="zoom: 33%;" /><p>相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。</p><p>这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 div.container 的 width 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。</p><p>这个答案实际上是不准确的。正确的答案应该是，<strong>div.item 的宽高是根据它的包含块来计算的</strong>，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。</p><p>因此正如我前面所说，<strong>很多时候你都感受不到包含块的存在。</strong></p><p>包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</p><p>另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：</p><ul><li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。</li><li>如果 position 属性是 fixed，那么包含块由视口建立。</li><li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li></ul><p>前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。</p><p>公布正确答案：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-153548.png"  style="zoom: 33%;" /><p>怎么样？有没有和你所想象的对上？</p><p>其实原因也非常简单，根据上面的第三条规则，对于 div.item2 来讲，它的包含块应该是 div.container，而非 div.item。</p><p>如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。</p><p>实际上对于非根元素来讲，包含块还有一种可能，那就是如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：</p><ul><li>transform 或 perspective 的值不是 none</li><li>will-change 的值是 transform 或 perspective </li><li>filter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效). </li><li>contain 的值是 paint (例如: contain: paint;)</li></ul><p>我们还是来看一个示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>); <span class="comment">/* 新增代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对于上面的代码只新增了一条声明，那就是 transform: rotate(0deg)，此时的渲染效果却发生了改变，如下图所示：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154347.png"  style="zoom:33%;" /><p>可以看到，此时对于 div.item2 来讲，包含块就变成了 div.item。</p><p>好了，到这里，关于包含块的知识就基本讲完了。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-14-154655.png"  style="zoom:33%;" /><p>我们再把 CSS 规范中所举的例子来看一下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Illustration of containing blocks<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>This is text in the first paragraph...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span></span><br><span class="line">        This is text</span><br><span class="line">        <span class="tag">&lt;<span class="name">em</span> <span class="attr">id</span>=<span class="string">&quot;em1&quot;</span>&gt;</span></span><br><span class="line">          in the</span><br><span class="line">          <span class="tag">&lt;<span class="name">strong</span> <span class="attr">id</span>=<span class="string">&quot;strong1&quot;</span>&gt;</span>second<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">          paragraph.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面是一段简单的 HTML 代码，在没有添加任何 CSS 代码的情况下，你能说出各自的包含块么？</p><p>对应的结果如下：</p><table><thead><tr><th>元素</th><th>包含块</th></tr></thead><tbody><tr><td>html</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>body</td><td>html</td></tr><tr><td>div1</td><td>body</td></tr><tr><td>p1</td><td>div1</td></tr><tr><td>p2</td><td>div1</td></tr><tr><td>em1</td><td>p2</td></tr><tr><td>strong1</td><td>p2</td></tr></tbody></table><p>首先 HTML 作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body 而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为 html，以此类推 div1、p1、p2 以及 em1 的包含块也都是它们的父元素。</p><p>不过 strong1 比较例外，它的包含块确实 p2，而非 em1。为什么会这样？建议你再把非根元素的第一条规则读一下：</p><ul><li>如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的<strong>块容器（block container）</strong>的内容区域（content area）的边缘建立。</li></ul><p>没错，因为 em1 不是块容器，而包含块是<strong>离它最近的块容器</strong>的内容区域，所以是 p2。</p><p>接下来添加如下的 CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div1</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50px</span>; <span class="attribute">top</span>: <span class="number">50px</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码我们对 div1 进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。</p><p>答案如下：</p><table><thead><tr><th>元素</th><th>包含块</th></tr></thead><tbody><tr><td>html</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>body</td><td>html</td></tr><tr><td>div1</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>p1</td><td>div1</td></tr><tr><td>p2</td><td>div1</td></tr><tr><td>em1</td><td>p2</td></tr><tr><td>strong1</td><td>p2</td></tr></tbody></table><p>可以看到，这里 div1 的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话：</p><ul><li>初始包含块（<strong>initial containing block</strong>）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。</li><li>如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。</li></ul><p>是不是一下子就理解了。没错，因为我们对 div1 进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的  position 的值不是 static 的祖先元素，不过显然 body 的定位方式为 static，因此 div1 的包含块最终就变成了初始包含块。</p><p>接下来我们继续修改我们的 CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div1</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50px</span>; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#em1</span>  &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们对 em1 同样进行了 absolute 绝对定位，你想一想会有什么样的变化？</p><p>没错，聪明的你大概应该知道，em1 的包含块不再是 p2，而变成了 div1，而 strong1 的包含块也不再是 p2 了，而是变成了 em1。</p><p>如下表所示：</p><table><thead><tr><th>元素</th><th>包含块</th></tr></thead><tbody><tr><td>html</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>body</td><td>html</td></tr><tr><td>div1</td><td>initial C.B. (UA-dependent)</td></tr><tr><td>p1</td><td>div1</td></tr><tr><td>p2</td><td>div1</td></tr><tr><td>em1</td><td>div1（因为定位了，参阅非根元素包含块确定规则的第三条）</td></tr><tr><td>strong1</td><td>em1（因为 em1 变为了块容器，参阅非根元素包含块确定规则的第一条）</td></tr></tbody></table><p>好了，这就是 CSS 规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的 CSS 规范的人。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-08-15-013519.png" style="zoom:33%;" /><p>另外，关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。</p><p>具体你可以移步到：<em><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block</a></em></p><p>好了，这就是有关包含块的所有内容了，你学会了么？-）</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包含块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript数组方法汇总</title>
      <link href="/post/7a776471.html"/>
      <url>/post/7a776471.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="使用数组字面量方法"><a href="#使用数组字面量方法" class="headerlink" title="使用数组字面量方法"></a>使用数组字面量方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [];    </span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">20</span>];   </span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">&#x27;lily&#x27;</span>,<span class="string">&#x27;lucy&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>];  </span><br></pre></td></tr></table></figure><h3 id="使用Array构造函数"><a href="#使用Array构造函数" class="headerlink" title="使用Array构造函数"></a>使用Array构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>();   <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);     <span class="comment">// 创建一个包含10项的数组</span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&#x27;lily&#x27;</span>,<span class="string">&#x27;lucy&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>);     <span class="comment">// 传入非数值或大于一个参数，创建一个包含3个字符串的数组</span></span><br></pre></td></tr></table></figure><h3 id="Array-of方法创建数组-es6新增"><a href="#Array-of方法创建数组-es6新增" class="headerlink" title="Array.of方法创建数组(es6新增)"></a>Array.of方法创建数组(es6新增)</h3><p>Array.of()方法会创建一个包含所有传入参数的数组，而不管参数的数量与类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = <span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//[1,2]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>); <span class="comment">//[3]</span></span><br></pre></td></tr></table></figure><h3 id="Array-from方法创建数组-es6新增"><a href="#Array-from方法创建数组-es6新增" class="headerlink" title="Array.from方法创建数组(es6新增)"></a>Array.from方法创建数组(es6新增)</h3><p>在js中将非数组对象转换为真正的数组是非常麻烦的。在es6中，将可迭代对象或者类数组对象作为第一个参数传入，Array.from()就能返回一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>]);</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(set); <span class="comment">// [ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">8</span>]]);</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(map); <span class="comment">// [[1, 2], [2, 4], [4, 8]]</span></span><br><span class="line"><span class="keyword">const</span> mapper = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]);</span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(mapper.<span class="title function_">values</span>()); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;];</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(mapper.<span class="title function_">keys</span>()); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><p>在<code>Array.from</code>中还可以使用箭头函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">x</span> =&gt;</span> x + x); <span class="comment">// [2, 4, 6]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> i); <span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>利用这一原理，可以设计如下序列生成器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">range</span> = (<span class="params">start, stop, step</span>) =&gt; <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: (stop - start) / step + <span class="number">1</span>&#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> start + (i * step));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate numbers range 0..4</span></span><br><span class="line"><span class="title function_">range</span>(<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>); <span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate numbers range 1..10 with step of 2</span></span><br><span class="line"><span class="title function_">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>); <span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the alphabet using Array.from making use of it being ordered as a sequence</span></span><br><span class="line"><span class="title function_">range</span>(<span class="string">&#x27;A&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>), <span class="string">&#x27;Z&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>), <span class="number">1</span>).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(x));</span><br><span class="line"><span class="comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>数组原型方法主要有以下这些：<br><code>join()</code>：用指定的分隔符将数组每一项拼接为字符串<br><code>push()</code>：向数组的末尾添加新元素<br><code>pop()</code>：删除数组的最后一项<br><code>unshift()</code>：向数组首位添加新元素<br><code>shift()</code>：删除数组的第一项<br><code>slice()</code>：按照条件查找出其中的部分元素<br><code>splice()</code>：对数组进行增删改<br><code>filter()</code>：过滤功能<br><code>concat()</code>：用于连接两个或多个数组<br><code>indexOf()</code>：检测当前值在数组中第一次出现的位置索引<br><code>lastIndexOf()</code>：检测当前值在数组中最后一次出现的位置索引<br><code>every()</code>：判断数组中每一项都是否满足条件<br><code>some()</code>：判断数组中是否存在满足条件的项<br><code>includes()</code>：判断一个数组是否包含一个指定的值<br><code>sort()</code>：对数组的元素进行排序<br><code>reverse()</code>：对数组进行倒序<br><code>forEach()</code>：es5及以下循环遍历数组每一项<br><code>map()</code>：es6循环遍历数组每一项<br><code>find()</code>：返回匹配的项<br><code>findIndex()</code>：返回匹配位置的索引<br><code>reduce()</code>：从数组的第一项开始遍历到最后一项，返回一个最终的值<br><code>reduceRight()</code>：从数组的最后一项开始遍历到第一项，返回一个最终的值<br><code>toLocaleString()</code>、<code>toString()</code>：将数组转换为字符串<br><code>entries()</code>、<code>keys()</code>、<code>values()</code>：遍历数组<br>欢迎补充…<br>各个方法功能详解</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>join()方法用于把数组中的所有元素转换一个字符串，默认使用逗号作为分隔符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1.<span class="title function_">join</span>());   <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>));   <span class="comment">// 1-2-3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [1,2,3](原数组不变)</span></span><br></pre></td></tr></table></figure><h3 id="push-和pop"><a href="#push-和pop" class="headerlink" title="push()和pop()"></a>push()和pop()</h3><p>push()方法从数组末尾向数组添加元素，可以添加一个或多个元素,并返回新的长度<br>pop()方法用于删除数组的最后一个元素并返回删除的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;lily&#x27;</span>,<span class="string">&#x27;lucy&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr1.<span class="title function_">push</span>(<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Sean&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count);   <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);   <span class="comment">// [&#x27;lily&#x27;,&#x27;lucy&#x27;,&#x27;Tom&#x27;,&#x27;Jack&#x27;,&#x27;Sean&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = arr1.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item);   <span class="comment">// Sean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);   <span class="comment">// [&#x27;lily&#x27;,&#x27;lucy&#x27;,&#x27;Tom&#x27;,&#x27;Jack&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="unshift-和shift"><a href="#unshift-和shift" class="headerlink" title="unshift()和shift()"></a>unshift()和shift()</h3><p>unshift()方法可向数组的开头添加一个或更多元素，并返回新的长度<br>shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;lily&#x27;</span>,<span class="string">&#x27;lucy&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> count = arr1.<span class="title function_">unshift</span>(<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Sean&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count);   <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);   <span class="comment">// [&#x27;Jack&#x27;,&#x27;Sean&#x27;,&#x27;lily&#x27;,&#x27;lucy&#x27;,&#x27;Tom&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = arr1.<span class="title function_">shift</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item);   <span class="comment">// Jack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);   <span class="comment">// [&#x27;&#x27;Sean&#x27;,&#x27;lily&#x27;,&#x27;lucy&#x27;,&#x27;Tom&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>用于对数组的元素进行排序。排序顺序可以是字母或数字，并按升序或降序，默认排序顺序为按字母升序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1.<span class="title function_">sort</span>());   <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1,value2</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(value1 &lt; value2)&#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">13</span>,<span class="number">24</span>,<span class="number">51</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2.<span class="title function_">sort</span>(compare));   <span class="comment">// [3,13,24,51]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要通过比较函数产生降序排序的结果，只要交后比较函数返回的值即可</span></span><br></pre></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>用于颠倒数组中元素的顺序，原数组改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">13</span>,<span class="number">24</span>,<span class="number">51</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1.<span class="title function_">reverse</span>());   <span class="comment">// [3,51,24,13]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);   <span class="comment">// [3,51,24,13](原数组改变)</span></span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>用于连接两个或多个数组，该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> arrCopy = arr1.<span class="title function_">concat</span>(<span class="number">9</span>,[<span class="number">11</span>,<span class="number">13</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrCopy);   <span class="comment">// [1,3,5,7,9,11,13]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);   <span class="comment">// [1,3,5,7](原数组未被修改)</span></span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>返回从原数组中指定开始下标到结束下标之间的项组成的新数组，可以接受一或两个参数，即要返回项的起始和结束位置(不包括结束位置的项)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> arrCopy = arr1.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> arrCopy2 = arr1.<span class="title function_">slice</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> arrCopy3 = arr1.<span class="title function_">slice</span>(<span class="number">1</span>,-<span class="number">2</span>);   <span class="comment">// 相当于arr1.slice(1,4);</span></span><br><span class="line"><span class="keyword">var</span> arrCopy4 = arr1.<span class="title function_">slice</span>(-<span class="number">4</span>,-<span class="number">1</span>);   <span class="comment">// 相当于arr1.slice(2,5);</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);   <span class="comment">// [1,3,5,7,9,11](原数组没变)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrCopy);   <span class="comment">// [3,5,7,9,11]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrCopy2);   <span class="comment">// [3,5,7]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrCopy3);   <span class="comment">// [3,5,7]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrCopy4);   <span class="comment">// [5,7,9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不传入参数二，那么将从参数一的索引位置开始截取，一直到数组尾</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">3</span>);    <span class="comment">//[1,2,3]</span></span><br><span class="line"><span class="keyword">var</span> c=a.<span class="title function_">slice</span>(<span class="number">3</span>);       <span class="comment">//[4,5,6]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果两个参数中的任何一个是负数，array.length会和它们相加，试图让它们成为非负数，举例说明：</span></span><br><span class="line"><span class="comment">//当只传入一个参数，且是负数时，length会与参数相加，然后再截取</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">slice</span>(-<span class="number">1</span>);    <span class="comment">//[6]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//当只传入一个参数，是负数时,并且参数的绝对值大于数组length时，会截取整个数组</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">slice</span>(-<span class="number">6</span>);    <span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line"><span class="keyword">var</span> c=a.<span class="title function_">slice</span>(-<span class="number">8</span>);    <span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//当传入两个参数一正一负时，length也会先于负数相加后，再截取</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">slice</span>(<span class="number">2</span>,-<span class="number">3</span>);    <span class="comment">//[3]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//当传入一个参数，大于length时，将返回一个空数组</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">slice</span>(<span class="number">6</span>);　　<span class="comment">//[]</span></span><br></pre></td></tr></table></figure><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>可以实现删除、插入和替换<br>包含三个及以上参数：开始位置、删除数量、插入元素（插入到开始位置前）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="keyword">var</span> a=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> b=a.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>);    <span class="comment">//a=[&#x27;a&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;c&#x27;],b=[&#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> arrRemoved = arr1.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);   <span class="comment">// [5,7,9,11]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrRemoved);   <span class="comment">// [1,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">22</span>,<span class="number">3</span>,<span class="number">31</span>,<span class="number">12</span>];</span><br><span class="line">arr1.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">35</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1);   <span class="comment">// [22,12,35,3,31,12]</span></span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>遍历数组。需要一个函数作为参数。数组中有几个参数，函数就执行几次，每次执行，浏览器就会把遍历到的元素作为实参传回，我们可以定义形参接受实参。浏览器会传递三个参数：正在遍历的元素、index(可省略)和正在遍历的数组（可省略）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum =<span class="number">0</span>;</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value,index,array</span>)&#123;</span><br><span class="line"></span><br><span class="line"> array[index] == value; <span class="comment">//结果为true</span></span><br><span class="line"></span><br><span class="line"> sum+=value; </span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">//结果为 10</span></span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>返回一个新数组，会按照原始数组元素顺序依次处理元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item * item;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray)  <span class="comment">// [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.<span class="property">every</span>.<span class="title function_">every</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x &lt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.<span class="title function_">every</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x &lt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.<span class="title function_">some</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x &lt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.<span class="title function_">some</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x &lt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>es6新增，用来判断一个数组、字符串是否包含一个指定的值，使用===运算符来进行值比较，如果是返回true，否则false，参数有两个，第一个是(必填)需要查找的元素值，第二个是(可选)开始查找元素的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">22</span>,<span class="number">3</span>,<span class="number">31</span>,<span class="number">12</span>,<span class="number">58</span>];</span><br><span class="line"><span class="keyword">var</span> includes = arr1.<span class="title function_">includes</span>(<span class="number">31</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(includes);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> includes2 = arr1.<span class="title function_">includes</span>(<span class="number">31</span>,<span class="number">3</span>);   <span class="comment">// 从索引3开始查找31是否存在</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(includes2);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="reduce-和reduceRight"><a href="#reduce-和reduceRight" class="headerlink" title="reduce()和reduceRight()"></a>reduce()和reduceRight()</h3><p>都会实现迭代数组的所有项(即累加器)，然后构建一个最终返回的值<br>reduce()方法从数组的第一项开始，逐个遍历到最后<br>reduceRight()方法从数组的最后一项开始。向前遍历到第一项<br>4个参数：前一个值、当前值、项的索引和数组对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr1.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev,cur,index,array</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;,<span class="number">10</span>);   <span class="comment">// 数组一开始加了一个初始值10，可以不设默认0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum);   <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h3 id="toLocaleString-和toString"><a href="#toLocaleString-和toString" class="headerlink" title="toLocaleString()和toString()"></a>toLocaleString()和toString()</h3><p>都是将数组转换为字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">22</span>,<span class="number">3</span>,<span class="number">31</span>,<span class="number">12</span>];</span><br><span class="line"><span class="keyword">let</span> str = arr1.<span class="title function_">toLocaleString</span>();</span><br><span class="line"><span class="keyword">var</span> str2 = arr1.<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);   <span class="comment">// 22,3,31,12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2);   <span class="comment">// 22,3,31,12</span></span><br></pre></td></tr></table></figure><h3 id="find-和findIndex"><a href="#find-和findIndex" class="headerlink" title="find()和findIndex()"></a>find()和findIndex()</h3><p>都接受两个参数：一个回调函数，一个可选值用于指定回调函数内部的this<br>该回调函数可接受3个参数：数组的某个元素、该元素对应的索引位置、数组本身，在回调函数第一次返回true时停止查找。<br>二者的区别是：find()方法返回匹配的值，而findIndex()方法返回匹配位置的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> num = arr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> num = arr.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="entries-、keys-和values"><a href="#entries-、keys-和values" class="headerlink" title="entries()、keys()和values()"></a>entries()、keys()和values()</h3><p>es6新增。entries()、keys()和values()–用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历<br>区别是keys()是对键名的遍历、values()是对键值的遍历、entries()是对键值对的遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">of</span> [a,b].<span class="title function_">keys</span>())&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> elem <span class="keyword">of</span> [a,b].<span class="title function_">values</span>())&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [index,elem] <span class="keyword">of</span> [a,b].<span class="title function_">entries</span>())&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(index,elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// 1 &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [a,b,c];</span><br><span class="line"><span class="keyword">let</span> entries = arrr1.<span class="title function_">entries</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>);   <span class="comment">// [0,a]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>);   <span class="comment">// [1,b]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>);   <span class="comment">// [2,c]</span></span><br></pre></td></tr></table></figure><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>indexof方法可以在字符串和数组上使用<br>indexOf() 方法可返回某个指定的字符串值在字符串、数组中首次出现的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;mfg&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;mfg&#x27;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;m&#x27;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;2017&#x27;</span>));<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">indexOf</span>(<span class="number">2017</span>)); <span class="comment">// -1，这里不会做隐式类型转换</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现水平并垂直居中的15种方法</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>利用CSS实现元素的水平并垂直居中是一个非常常见的面试问题，以下将列出部分常用方法。</p><h2 id="一、基础代码"><a href="#一、基础代码" class="headerlink" title="一、基础代码"></a>一、基础代码</h2><p>为使示例更清晰，编写如下基础代码：</p><h3 id="基础HTML"><a href="#基础HTML" class="headerlink" title="基础HTML"></a>基础HTML</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基础CSS"><a href="#基础CSS" class="headerlink" title="基础CSS"></a>基础CSS</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="居中实现"><a href="#居中实现" class="headerlink" title="居中实现"></a>居中实现</h2><h3 id="一、绝对定位-margin"><a href="#一、绝对定位-margin" class="headerlink" title="一、绝对定位 + margin"></a>一、绝对定位 + margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、绝对定位-calc"><a href="#二、绝对定位-calc" class="headerlink" title="二、绝对定位 + calc"></a>二、绝对定位 + calc</h3><p>本方法实际上与方法一一致，优点是无需手动计算，缺点是可能存在兼容性问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="comment">/*position: absolute;*/</span></span><br><span class="line">    <span class="comment">/*top: calc(50% - 50px);*/</span></span><br><span class="line">    <span class="comment">/*left: calc(50% - 50px);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*或者*/</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attr">--widthChild</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attr">--heightChild</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">var</span>(--widthChild);</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">var</span>(--heightChild);</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="built_in">calc</span>(<span class="built_in">var</span>(--widthChild) / <span class="number">2</span>));</span><br><span class="line">    <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="built_in">calc</span>(<span class="built_in">var</span>(--heightChild) / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、绝对定位-transform"><a href="#三、绝对定位-transform" class="headerlink" title="三、绝对定位 + transform"></a>三、绝对定位 + transform</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、绝对定位-margin-auto"><a href="#四、绝对定位-margin-auto" class="headerlink" title="四、绝对定位 + margin(auto)"></a>四、绝对定位 + margin(auto)</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、text-align"><a href="#五、text-align" class="headerlink" title="五、text-align"></a>五、text-align</h3><p>仅适用于文本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">line-height</span>: initial;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、table-cell布局"><a href="#六、table-cell布局" class="headerlink" title="六、table-cell布局"></a>六、table-cell布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、flex布局"><a href="#七、flex布局" class="headerlink" title="七、flex布局"></a>七、flex布局</h3><p>最常用、最简单的方法，IE浏览器有一定的兼容性问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、Grid布局"><a href="#八、Grid布局" class="headerlink" title="八、Grid布局"></a>八、Grid布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">    justify-self: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九、writing-mode-text-align"><a href="#九、writing-mode-text-align" class="headerlink" title="九、writing-mode + text-align"></a>九、writing-mode + text-align</h3><p>仅适用于文字</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">writing-mode</span>: vertical-lr;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">writing-mode</span>: horizontal-tb;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十、伪元素-calc"><a href="#十、伪元素-calc" class="headerlink" title="十、伪元素 + calc"></a>十、伪元素 + calc</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">5px</span>; <span class="comment">/*content宽度*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attr">--widthChild</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">var</span>(--widthChild);</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="built_in">calc</span>(<span class="built_in">calc</span>(<span class="number">50%</span> - <span class="built_in">calc</span>(<span class="built_in">var</span>(--widthChild) / <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十一、flex-margin"><a href="#十一、flex-margin" class="headerlink" title="十一、flex + margin"></a>十一、flex + margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十二、flex-align-self-margin"><a href="#十二、flex-align-self-margin" class="headerlink" title="十二、flex + align-self + margin"></a>十二、flex + align-self + margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十三、网格-伪元素-margin"><a href="#十三、网格-伪元素-margin" class="headerlink" title="十三、网格 + 伪元素 + margin"></a>十三、网格 + 伪元素 + margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.father</span><span class="selector-pseudo">::before</span>,<span class="selector-class">.father</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十四、纯网格"><a href="#十四、纯网格" class="headerlink" title="十四、纯网格"></a>十四、纯网格</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">grid-row</span>: <span class="number">2</span> / span <span class="number">1</span>; <span class="comment">/*也可以使用2/3*/</span></span><br><span class="line">    <span class="attribute">grid-column</span>: <span class="number">2</span> / span <span class="number">1</span>; <span class="comment">/*也可以使用2/3*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十五、网格-margin"><a href="#十五、网格-margin" class="headerlink" title="十五、网格 + margin"></a>十五、网格 + margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.让元素居中的方法，最通用的是采用<code>flex</code>布局<br>2.知道自身宽高的情况下，可使用<code>margin-left</code>和<code>margin-top</code>为负值的方法<br>3.不知道自身元素宽高的情况下，可使用<code>transform: translate</code>或<code>top、bottom、right、left = 0</code>的方法</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水平居中 </tag>
            
            <tag> 垂直居中 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
